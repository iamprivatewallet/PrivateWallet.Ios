// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tx.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Tx.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - TxRoot

@implementation TxRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - TxRoot_FileDescriptor

static GPBFileDescriptor *TxRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"org.brewchain.evmapi.gens"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - MultiTransaction

@implementation MultiTransaction

@dynamic txHash;
@dynamic hasTxBody, txBody;
@dynamic status;
@dynamic hasTxNode, txNode;
@dynamic result;

typedef struct MultiTransaction__storage_ {
  uint32_t _has_storage_[1];
  NSString *txHash;
  MultiTransactionBody *txBody;
  NSString *status;
  MultiTransactionNode *txNode;
  NSData *result;
} MultiTransaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txHash",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransaction_FieldNumber_TxHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MultiTransaction__storage_, txHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txBody",
        .dataTypeSpecific.className = GPBStringifySymbol(MultiTransactionBody),
        .number = MultiTransaction_FieldNumber_TxBody,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MultiTransaction__storage_, txBody),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransaction_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MultiTransaction__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txNode",
        .dataTypeSpecific.className = GPBStringifySymbol(MultiTransactionNode),
        .number = MultiTransaction_FieldNumber_TxNode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MultiTransaction__storage_, txNode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransaction_FieldNumber_Result,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MultiTransaction__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MultiTransaction class]
                                     rootClass:[TxRoot class]
                                          file:TxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MultiTransaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\006\000\002\006\000\004\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MultiTransactionBody

@implementation MultiTransactionBody

@dynamic inputsArray, inputsArray_Count;
@dynamic outputsArray, outputsArray_Count;
@dynamic exdata;
@dynamic signaturesArray, signaturesArray_Count;
@dynamic delegateArray, delegateArray_Count;
@dynamic data_p;
@dynamic timestamp;
@dynamic type;

typedef struct MultiTransactionBody__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  NSMutableArray *inputsArray;
  NSMutableArray *outputsArray;
  NSData *exdata;
  NSMutableArray *signaturesArray;
  NSMutableArray *delegateArray;
  NSData *data_p;
  int64_t timestamp;
} MultiTransactionBody__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MultiTransactionInput),
        .number = MultiTransactionBody_FieldNumber_InputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiTransactionBody__storage_, inputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MultiTransactionOutput),
        .number = MultiTransactionBody_FieldNumber_OutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiTransactionBody__storage_, outputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "exdata",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionBody_FieldNumber_Exdata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MultiTransactionBody__storage_, exdata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signaturesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MultiTransactionSignature),
        .number = MultiTransactionBody_FieldNumber_SignaturesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiTransactionBody__storage_, signaturesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "delegateArray",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionBody_FieldNumber_DelegateArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiTransactionBody__storage_, delegateArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionBody_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MultiTransactionBody__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionBody_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MultiTransactionBody__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionBody_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MultiTransactionBody__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MultiTransactionBody class]
                                     rootClass:[TxRoot class]
                                          file:TxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MultiTransactionBody__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MultiTransactionInput

@implementation MultiTransactionInput

@dynamic nonce;
@dynamic address;
@dynamic amount;
@dynamic token;
@dynamic symbol;
@dynamic cryptoToken;

typedef struct MultiTransactionInput__storage_ {
  uint32_t _has_storage_[1];
  int32_t nonce;
  NSData *address;
  NSData *amount;
  NSString *token;
  NSString *symbol;
  NSData *cryptoToken;
} MultiTransactionInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionInput_FieldNumber_Nonce,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MultiTransactionInput__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionInput_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MultiTransactionInput__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionInput_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MultiTransactionInput__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionInput_FieldNumber_Token,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MultiTransactionInput__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "symbol",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionInput_FieldNumber_Symbol,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MultiTransactionInput__storage_, symbol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cryptoToken",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionInput_FieldNumber_CryptoToken,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MultiTransactionInput__storage_, cryptoToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MultiTransactionInput class]
                                     rootClass:[TxRoot class]
                                          file:TxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MultiTransactionInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\t\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MultiTransactionOutput

@implementation MultiTransactionOutput

@dynamic address;
@dynamic amount;
@dynamic symbol;
@dynamic cryptoToken;

typedef struct MultiTransactionOutput__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  NSData *amount;
  NSString *symbol;
  NSData *cryptoToken;
} MultiTransactionOutput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionOutput_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MultiTransactionOutput__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionOutput_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MultiTransactionOutput__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "symbol",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionOutput_FieldNumber_Symbol,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MultiTransactionOutput__storage_, symbol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cryptoToken",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionOutput_FieldNumber_CryptoToken,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MultiTransactionOutput__storage_, cryptoToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MultiTransactionOutput class]
                                     rootClass:[TxRoot class]
                                          file:TxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MultiTransactionOutput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MultiTransactionSignature

@implementation MultiTransactionSignature

@dynamic signature;

typedef struct MultiTransactionSignature__storage_ {
  uint32_t _has_storage_[1];
  NSData *signature;
} MultiTransactionSignature__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionSignature_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MultiTransactionSignature__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MultiTransactionSignature class]
                                     rootClass:[TxRoot class]
                                          file:TxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MultiTransactionSignature__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MultiTransactionNode

@implementation MultiTransactionNode

@dynamic node;
@dynamic address;
@dynamic bcuid;

typedef struct MultiTransactionNode__storage_ {
  uint32_t _has_storage_[1];
  NSString *node;
  NSData *address;
  NSString *bcuid;
} MultiTransactionNode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "node",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionNode_FieldNumber_Node,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MultiTransactionNode__storage_, node),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionNode_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MultiTransactionNode__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "bcuid",
        .dataTypeSpecific.className = NULL,
        .number = MultiTransactionNode_FieldNumber_Bcuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MultiTransactionNode__storage_, bcuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MultiTransactionNode class]
                                     rootClass:[TxRoot class]
                                          file:TxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MultiTransactionNode__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BroadcastTransactionMsg

@implementation BroadcastTransactionMsg

@dynamic txHashArray, txHashArray_Count;
@dynamic txDatasArray, txDatasArray_Count;

typedef struct BroadcastTransactionMsg__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *txHashArray;
  NSMutableArray *txDatasArray;
} BroadcastTransactionMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txHashArray",
        .dataTypeSpecific.className = NULL,
        .number = BroadcastTransactionMsg_FieldNumber_TxHashArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BroadcastTransactionMsg__storage_, txHashArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "txDatasArray",
        .dataTypeSpecific.className = NULL,
        .number = BroadcastTransactionMsg_FieldNumber_TxDatasArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BroadcastTransactionMsg__storage_, txDatasArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BroadcastTransactionMsg class]
                                     rootClass:[TxRoot class]
                                          file:TxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BroadcastTransactionMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000txHash\000\002\000txDatas\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CryptoTokenData

@implementation CryptoTokenData

@dynamic total;
@dynamic symbol;
@dynamic extData;
@dynamic nameArray, nameArray_Count;
@dynamic codeArray, codeArray_Count;

typedef struct CryptoTokenData__storage_ {
  uint32_t _has_storage_[1];
  NSString *symbol;
  NSData *extData;
  NSMutableArray *nameArray;
  NSMutableArray *codeArray;
  int64_t total;
} CryptoTokenData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = CryptoTokenData_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CryptoTokenData__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "symbol",
        .dataTypeSpecific.className = NULL,
        .number = CryptoTokenData_FieldNumber_Symbol,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CryptoTokenData__storage_, symbol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extData",
        .dataTypeSpecific.className = NULL,
        .number = CryptoTokenData_FieldNumber_ExtData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CryptoTokenData__storage_, extData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nameArray",
        .dataTypeSpecific.className = NULL,
        .number = CryptoTokenData_FieldNumber_NameArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CryptoTokenData__storage_, nameArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "codeArray",
        .dataTypeSpecific.className = NULL,
        .number = CryptoTokenData_FieldNumber_CodeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CryptoTokenData__storage_, codeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CryptoTokenData class]
                                     rootClass:[TxRoot class]
                                          file:TxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CryptoTokenData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnionAccountData

@implementation UnionAccountData

@dynamic max;
@dynamic acceptMax;
@dynamic acceptLimit;
@dynamic addressArray, addressArray_Count;

typedef struct UnionAccountData__storage_ {
  uint32_t _has_storage_[1];
  int32_t acceptLimit;
  NSData *max;
  NSData *acceptMax;
  NSMutableArray *addressArray;
} UnionAccountData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "max",
        .dataTypeSpecific.className = NULL,
        .number = UnionAccountData_FieldNumber_Max,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnionAccountData__storage_, max),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "acceptMax",
        .dataTypeSpecific.className = NULL,
        .number = UnionAccountData_FieldNumber_AcceptMax,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnionAccountData__storage_, acceptMax),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "acceptLimit",
        .dataTypeSpecific.className = NULL,
        .number = UnionAccountData_FieldNumber_AcceptLimit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnionAccountData__storage_, acceptLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "addressArray",
        .dataTypeSpecific.className = NULL,
        .number = UnionAccountData_FieldNumber_AddressArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UnionAccountData__storage_, addressArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnionAccountData class]
                                     rootClass:[TxRoot class]
                                          file:TxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnionAccountData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\t\000\003\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SanctionData

@implementation SanctionData

@dynamic content;
@dynamic endBlockHeight;
@dynamic result;

typedef struct SanctionData__storage_ {
  uint32_t _has_storage_[1];
  NSData *content;
  NSData *result;
  int64_t endBlockHeight;
} SanctionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = SanctionData_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SanctionData__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "endBlockHeight",
        .dataTypeSpecific.className = NULL,
        .number = SanctionData_FieldNumber_EndBlockHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SanctionData__storage_, endBlockHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = SanctionData_FieldNumber_Result,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SanctionData__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SanctionData class]
                                     rootClass:[TxRoot class]
                                          file:TxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SanctionData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
